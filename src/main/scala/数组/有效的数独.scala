package 数组

/**
 * leetcode-36
 */
object 有效的数独 {



  def main(args: Array[String]): Unit = {
   val board = Array(Array('5','3','.','.','7','.','.','.','.') ,Array('6','.','.','1','9','5','.','.','.') ,Array('.','9','8','.','.','.','.','6','.') ,Array('8','.','.','.','6','.','.','.','3') ,Array('4','.','.','8','.','3','.','.','1') ,Array('7','.','.','.','2','.','.','.','6') ,Array('.','6','.','.','.','.','2','8','.') ,Array('.','.','.','4','1','9','.','.','5') ,Array('.','.','.','.','8','.','.','7','9'))
   println( isValidSudoku(board))

    val b1 =  Array(Array('8','3','.','.','7','.','.','.','.') ,Array('6','.','.','1','9','5','.','.','.') ,Array('.','9','8','.','.','.','.','6','.') ,Array('8','.','.','.','6','.','.','.','3') ,Array('4','.','.','8','.','3','.','.','1') ,Array('7','.','.','.','2','.','.','.','6') ,Array('.','6','.','.','.','.','2','8','.') ,Array('.','.','.','4','1','9','.','.','5') ,Array('.','.','.','.','8','.','.','7','9'))
    println( isValidSudoku(b1))

    val b2 =  Array(Array('.','.','.','9','.','.','.','.','.'),Array('.','.','.','.','.','.','.','.','.'),Array('.','.','3','.','.','.','.','.','1'),Array('.','.','.','.','.','.','.','.','.'),Array('1','.','.','.','.','.','3','.','.'),Array('.','.','.','.','2','.','6','.','.'),Array('.','9','.','.','.','.','.','7','.'),Array('.','.','.','.','.','.','.','.','.'),Array('8','.','.','8','.','.','.','.','.'))
    println( isValidSudoku(b2))

  }


  /**
   * 数字只有1-9，所以在表示的时候，使用数组的下标来代替数字是存在，还可以在其中存入位置
   * 定义两个9x9二维数组，一个代表行 row，一个代表列 col
   * row(1,1) 代表第一行中 是否存在1，如果存在，存储所在的列下标
   * col(1,1) 代表第一列中 是否存在1，如果存在，存储所在的行下标
   *
   *  如果要检查board(x,y) =z 是否满足数独
   *  row(x,z) == null && col(y,z) == null && 满足所在9宫不存在相同的数字
   *  如何求所在的九宫
   *  i = k * (x/3+1) { 0< k <= 3 }
   *  j = k* (y/3+1) { 0< k <= 3 }
   *
   *  (x/3+1,y/3+1)
   *
   *
   * @param board
   * @return
   */
  def isValidSudoku(board: Array[Array[Char]]): Boolean = {
    val map = Array.ofDim[Int](3,3)
    map(0) = Array(0,1,2)
    map(1) = Array(3,4,5)
    map(2) = Array(6,7,8)
    // 可以使用位计算来存储当前状态
    val row = Array.ofDim[Int](9,9)
    val col = Array.ofDim[Int](9,9)

    for(r <- map){
      for (c <- map){
        val result = Array.ofDim[Int](9)
        for (m <- r){
          for (n <- c){
            val k = board(m)(n)
            if(k != '.') {
              k.getNumericValue
             val ki = (k - '0').intValue-1
              if (row(m)(ki) > 0 || col(n)(ki) > 0) {
                return false
              }
              row(m)(ki) = n+1
              col(n)(ki) = m+1
              if (result(ki) > 0) {
                return false;
              }
              result(ki) = 1
            }
          }
        }
      }
    }
    true

  }

}
